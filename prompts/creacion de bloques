Gu√≠a para la Creaci√≥n y Configuraci√≥n de Bloques

Nuestro sistema de bloques se estructura en cinco pasos clave para garantizar una integraci√≥n y renderizaci√≥n coherente en el proyecto. A continuaci√≥n, se detalla cada uno de ellos:

Registro de Datos en la Base de Datos
Cada bloque se define registrando la informaci√≥n necesaria en la base de datos. Por ejemplo, para un bloque "hero", se almacena la siguiente configuraci√≥n:

javascript
export const blockTypes = {
hero: {
  name: 'Hero',
  description: 'T√≠tulo con descripci√≥n y 3 botones centrados',
  icon: 'üñºÔ∏è',
  defaultConfig: {
    title: 'T√≠tulo principal',
    subtitle: 'Subt√≠tulo descriptivo',
    backgroundColor: '#F7EFCB',
    image: '',
    blobs: [], // Array para almacenar m√∫ltiples manchas
    buttonText1: 'Ver m√°s',
    buttonUrl1: '#',
    buttonColor1: '#007bff',
  }
},
};
Creaci√≥n del Componente Configurador
Se desarrolla un componente React que maneja la l√≥gica de configuraci√≥n del bloque en el frontend. Este componente, por ejemplo HeroConfigurator, permite editar campos como t√≠tulo, subt√≠tulo, im√°genes, y datos de los botones, adem√°s de gestionar galer√≠as para im√°genes y manchas:

javascript
import { useState } from 'react';
import ImageGallery from '../../AdminImageGallery';
import styles from '../render/styles/configuratorBlock.module.css';
import RichTextEditor from '../../dnd/RichTextEditor';

const HeroConfigurator = ({ config, onChange }) => {
  // Estados y funciones de manejo para editar configuraci√≥n
  // ...
  return (
    <>
      <label className={styles.label}>
        T√≠tulo:
        <input
          type="text"
          value={config.title || ''}
          onChange={(e) => handleChange('title', e.target.value)}
          className={styles.input}
        />
      </label>

      <label className={styles.label}>
  Parraffo:
  <RichTextEditor
    value={config.subtitle || ''}
    onChange={(content) => handleChange('subtitle', content)}
  />
</label>
      {/* Se repite la estructura para cada campo (subt√≠tulo, botones, colores, imagen de fondo, etc.) */}
    </>
  );
};

export default HeroConfigurator;
Registro de la Configuraci√≥n
Al configurar un bloque, se invoca el componente configurador correspondiente. Por ejemplo, al detectar un bloque de tipo "hero", se carga el HeroConfigurator:

jsx
{block.type === 'hero' && (
  <HeroConfigurator config={config} onChange={handleChange} />
)}
L√≥gica de Renderizado del Bloque
Se implementa la renderizaci√≥n del bloque utilizando la informaci√≥n configurada. En el caso del bloque "hero", se utiliza un componente HeroBlock que aplica estilos y renderiza cada elemento (t√≠tulo, subt√≠tulo, botones y manchas) de forma din√°mica:

javascript
import React from 'react';
import DOMPurify from 'dompurify';
import styles from "./styles/heroBlock.module.css";

const HeroBlock = ({ configuration }) => {
  const backgroundStyle = configuration?.image 
    ? { backgroundImage: `url(${configuration.image})` } 
    : { backgroundColor: configuration?.backgroundColor || '#ffffff' };

  return (
    <div className={styles.previewHero} style={backgroundStyle}>
      {/* Renderizaci√≥n de manchas decorativas */}
      {configuration.blobs?.map((blob, index) => {
        const side = index % 2 === 0 ? '1%' : '80%';
        const topPos = Math.random() * 80;
        return (
          <img
            key={index}
            src={blob}
            alt={`Mancha decorativa ${index + 1}`}
            className={styles.blob}
            style={{ top: `${topPos}%`, left: side }}
          />
        );
      })}
      <div className={styles.heroContent}>
        {configuration?.title && (
          <h2 className={styles.heroTitle}>{configuration.title}</h2>
        )}
        <p dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(configuration.subtitle || '') }} />
        <div className={styles.buttonContainer}>
          {configuration?.buttonText1 && (
            <a
              href={configuration.buttonUrl1 || '#'}
              className={styles.heroButton}
              style={{ backgroundColor: configuration.buttonColor1 || '#007bff' }}
            >
              {configuration.buttonText1}
            </a>
          )}
          {/* Se renderizan los botones 2 y 3 de forma similar */}
        </div>
      </div>
    </div>
  );
};

export default HeroBlock;
Registro del Bloque para Renderizado
Finalmente, se registra el bloque en la l√≥gica de renderizado general. Seg√∫n el tipo de bloque, se invoca el componente correspondiente dentro de un switch o estructura condicional:

jsx
switch (block.type) {
  case 'hero':
    return (
      <div className={containerClass}>
        <HeroBlock configuration={block.configuration} />
      </div>
    );
  // Se a√±aden otros casos para diferentes tipos de bloques
}

entre algunos detalles tambien se usa estilos modulares style. css
tambien para modificar textos se usa RichTextEditor y luego en el renderidador se usa para renderizar el texto

